<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>BST Traversal Visualizer (Proper SVG Tree)</title>
<style>
  :root{
    --bg1:#f5f8ff; --bg2:#eaf0ff;
    --panel:#ffffff; --ink:#1f2937;
    --accent:#4a90e2; --accent-2:#357ABD;
    --node:#10b981; --active:#ff9800; --edge:#64748b;
  }
  body{
    margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    color:var(--ink); background:linear-gradient(135deg,var(--bg1),var(--bg2));
  }
  .wrap{max-width:1100px; margin:24px auto; padding:0 16px;}
  h1{font-weight:800; letter-spacing:.2px; margin:4px 0 12px;}
  .controls{
    display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:8px 0 16px;
    background:var(--panel); padding:12px; border-radius:16px; box-shadow:0 10px 30px rgba(30,41,59,.08);
  }
  .controls select,.controls button,.controls input[type="range"]{
    border:none; border-radius:10px; padding:10px 14px; font-size:14px;
    background:var(--accent); color:#fff; cursor:pointer; transition:.2s;
    box-shadow:0 4px 14px rgba(76,110,245,.18);
  }
  .controls select{appearance:none; background:var(--accent);}
  .controls button:hover,.controls select:hover{background:var(--accent-2);}
  .controls .ghost{background:#e5edff; color:var(--accent-2)}
  .controls .ghost:hover{background:#d9e6ff}
  .controls label{font-size:13px; color:#374151; font-weight:600; margin-left:8px}
  .controls .range{
    display:flex; align-items:center; gap:10px; padding:8px 12px; background:#f1f5ff; border-radius:12px;
  }
  .controls input[type="range"]{accent-color:var(--accent); background:#fff; padding:0 0; box-shadow:none; width:160px}
  .viz{
    background:var(--panel); border-radius:18px; box-shadow:0 20px 40px rgba(30,41,59,.08);
    padding:12px; overflow:hidden;
  }
  svg{width:100%; height:560px; display:block; border-radius:14px; background:#ffffff}
  .edge{stroke:var(--edge); stroke-width:2.5; stroke-linecap:round; transition:stroke .2s, stroke-width .2s; opacity:.95}
  .edge.active{stroke:var(--active); stroke-width:3.5}
  .node{cursor:default}
  .node circle{
    fill:var(--node); stroke:#0f766e; stroke-width:2;
    filter:drop-shadow(0 2px 4px rgba(0,0,0,.12));
    transition:transform .25s, fill .25s, stroke .25s, filter .25s;
  }
  .node text{fill:#ffffff; font-weight:700; font-size:12px; text-anchor:middle; dominant-baseline:middle; pointer-events:none}
  .node.active circle{
    fill:var(--active); stroke:#c2410c;
    filter:drop-shadow(0 0 12px rgba(255,152,0,.55));
    transform:scale(1.18);
  }

  .output{
    margin:14px 0 8px; background:#fff; padding:10px 14px; border-radius:12px;
    box-shadow:0 10px 30px rgba(30,41,59,.06); font-size:14px;
    word-wrap:break-word; min-height:22px;
  }
  .legend{font-size:12px; color:#475569; margin-top:6px}
  .spacer{flex:1 1 auto}
</style>
</head>
<body>
<div class="wrap">
  <h1>BST Traversal Visualizer</h1>

  <div class="controls">
    <select id="treeSelect" title="Choose a sample BST">
      <option value="A">Tree A — [8,3,10,1,6,14,4,7,13]</option>
      <option value="B">Tree B — Balanced-ish [50,30,70,20,40,60,80,35,45,65,75]</option>
      <option value="C">Tree C — Right-heavy [10,12,15,20,25,30]</option>
    </select>
    <button id="loadBtn">Load Tree</button>

    <div class="spacer"></div>

    <button class="ghost" id="preBtn">Preorder</button>
    <button class="ghost" id="inBtn">Inorder</button>
    <button class="ghost" id="postBtn">Postorder</button>
    <button class="ghost" id="bfsBtn">Level Order</button>

    <div class="range">
      <label for="speed">Speed</label>
      <input id="speed" type="range" min="200" max="1500" step="50" value="800"/>
    </div>

    <button id="resetBtn">Reset</button>
  </div>

  <div class="viz">
    <svg id="svg" viewBox="0 0 1000 560" preserveAspectRatio="xMidYMid meet" aria-label="BST visualization">
      <defs>
        <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5"
                markerWidth="6" markerHeight="6" orient="auto-start-reverse">
          <path d="M 0 0 L 10 5 L 0 10 z" fill="currentColor"></path>
        </marker>
      </defs>
      <!-- edges and nodes will be injected here -->
    </svg>
  </div>

  <div id="output" class="output">Traversal: <span id="order"></span></div>
  <div class="legend">Tip: Use the dropdown to switch trees. Edges are drawn with precise geometry so they touch the node borders cleanly. Traversal highlights the node and briefly the entering edge.</div>
</div>

<script>
/* ---------- Data & BST building ---------- */
const presets = {
  A: [8,3,10,1,6,14,4,7,13],
  B: [50,30,70,20,40,60,80,35,45,65,75],
  C: [10,12,15,20,25,30]
};
function makeNode(v){ return {value:v, left:null, right:null}; }
function insert(root, v){
  if(!root) return makeNode(v);
  if(v < root.value) root.left = insert(root.left, v);
  else root.right = insert(root.right, v);
  return root;
}
function buildBST(values){
  let root = null;
  for(const v of values) root = insert(root, v);
  return root;
}

/* ---------- Layout via Inorder indexing (tidy enough for BSTs) ---------- */
function layoutTree(root, width=1000, height=560){
  // Compute depth and collect nodes
  const nodes = [];
  const edges = [];
  let maxDepth = 0;

  function dfsDepth(n, depth, parent=null){
    if(!n) return;
    if(depth > maxDepth) maxDepth = depth;
    dfsDepth(n.left, depth+1, n);
    nodes.push({n, depth, parent});
    dfsDepth(n.right, depth+1, n);
  }
  dfsDepth(root, 0, null);

  const count = nodes.length || 1;
  const marginX = 60, marginY = 50;
  const hGap = (width - 2*marginX) / (count + 1);
  const vGap = (height - 2*marginY) / (Math.max(1, maxDepth));

  // assign inorder index as x position
  nodes.forEach((item, i) => {
    item.x = marginX + (i+1)*hGap;
    item.y = marginY + item.depth*vGap;
  });

  // Map real node -> positioned record
  const posByValue = new Map(nodes.map(o => [o.n.value, o]));

  // build edges (parent -> child)
  for(const {n} of nodes){
    if(n.left){
      edges.push({from:n.value, to:n.left.value});
    }
    if(n.right){
      edges.push({from:n.value, to:n.right.value});
    }
  }
  return {nodes, edges, posByValue, maxDepth};
}

/* ---------- SVG Drawing Helpers ---------- */
const svg = document.getElementById('svg');
function clearSVG(){
  while(svg.lastChild) svg.removeChild(svg.lastChild);
  // keep defs (first child)
  // Re-add defs if removed
}
function drawTree(root){
  clearSVG();
  const W = 1000, H = 560;
  const R = 20;

  const {nodes, edges, posByValue} = layoutTree(root, W, H);

  // Draw edges first
  for(const e of edges){
    const a = posByValue.get(e.from);
    const b = posByValue.get(e.to);

    // compute line endpoints that touch circle borders, not centers
    const dx = b.x - a.x, dy = b.y - a.y;
    const len = Math.hypot(dx, dy) || 1;
    const ux = dx/len, uy = dy/len;

    const x1 = a.x + ux*R, y1 = a.y + uy*R;
    const x2 = b.x - ux*R, y2 = b.y - uy*R;

    const line = document.createElementNS("http://www.w3.org/2000/svg","line");
    line.setAttribute("x1", x1); line.setAttribute("y1", y1);
    line.setAttribute("x2", x2); line.setAttribute("y2", y2);
    line.setAttribute("class","edge");
    line.setAttribute("id", `e_${e.from}_${e.to}`);
    svg.appendChild(line);
  }

  // Draw nodes
  for(const {n, x, y} of nodes){
    const g = document.createElementNS("http://www.w3.org/2000/svg","g");
    g.setAttribute("class","node");
    g.setAttribute("id", `n_${n.value}`);

    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", x); c.setAttribute("cy", y); c.setAttribute("r", R);

    const t = document.createElementNS("http://www.w3.org/2000/svg","text");
    t.setAttribute("x", x); t.setAttribute("y", y+1); // slight vertical optical align
    t.textContent = n.value;

    g.appendChild(c); g.appendChild(t);
    svg.appendChild(g);
  }
}

/* ---------- Traversals (produce sequence & parent map) ---------- */
function parentsMap(root){
  const p = new Map();
  (function dfs(n, par=null){
    if(!n) return;
    p.set(n.value, par ? par.value : null);
    dfs(n.left, n); dfs(n.right, n);
  })(root,null);
  return p;
}
function preorder(root, out=[]){
  if(!root) return out;
  out.push(root.value); preorder(root.left,out); preorder(root.right,out);
  return out;
}
function inorder(root, out=[]){
  if(!root) return out;
  inorder(root.left,out); out.push(root.value); inorder(root.right,out);
  return out;
}
function postorder(root, out=[]){
  if(!root) return out;
  postorder(root.left,out); postorder(root.right,out); out.push(root.value);
  return out;
}
function levelorder(root){
  const out=[]; if(!root) return out;
  const q=[root];
  while(q.length){
    const cur=q.shift(); out.push(cur.value);
    if(cur.left) q.push(cur.left);
    if(cur.right) q.push(cur.right);
  }
  return out;
}

/* ---------- Animation ---------- */
let currentRoot = buildBST(presets.A);
let runToken = 0;

function setActiveNode(v, on){
  const el = document.getElementById(`n_${v}`);
  if(el) el.classList.toggle('active', !!on);
}
function flashEdge(parent, child, ms){
  if(parent==null) return;
  const e = document.getElementById(`e_${parent}_${child}`);
  if(!e) return;
  e.classList.add('active');
  setTimeout(()=> e.classList.remove('active'), Math.min(ms, 900));
}

function animateTraversal(sequence, pMap){
  const orderSpan = document.getElementById('order');
  orderSpan.textContent = '';
  // clear previous states
  document.querySelectorAll('.node.active').forEach(n => n.classList.remove('active'));
  document.querySelectorAll('.edge.active').forEach(e => e.classList.remove('active'));

  const token = ++runToken;
  const speed = +document.getElementById('speed').value;

  let i = 0;
  (function step(){
    if(token !== runToken) return; // cancelled by a new run
    if(i > 0) setActiveNode(sequence[i-1], false);
    if(i >= sequence.length) return;

    const v = sequence[i];
    const parent = pMap.get(v);
    setActiveNode(v, true);
    flashEdge(parent, v, speed);

    orderSpan.textContent += (i? ' ' : '') + v;
    i++;
    setTimeout(step, speed);
  })();
}

/* ---------- Wiring UI ---------- */
const treeSelect = document.getElementById('treeSelect');
document.getElementById('loadBtn').onclick = () => {
  currentRoot = buildBST(presets[treeSelect.value]);
  drawTree(currentRoot);
  ++runToken; // cancel any running animation
  document.getElementById('order').textContent = '';
};

document.getElementById('preBtn').onclick  = () => animateTraversal(preorder(currentRoot, []), parentsMap(currentRoot));
document.getElementById('inBtn').onclick   = () => animateTraversal(inorder(currentRoot, []), parentsMap(currentRoot));
document.getElementById('postBtn').onclick = () => animateTraversal(postorder(currentRoot, []), parentsMap(currentRoot));
document.getElementById('bfsBtn').onclick  = () => animateTraversal(levelorder(currentRoot), parentsMap(currentRoot));

document.getElementById('resetBtn').onclick = () => {
  ++runToken;
  drawTree(currentRoot);
  document.getElementById('order').textContent = '';
};

// initial draw
drawTree(currentRoot);
</script>
</body>
</html>
